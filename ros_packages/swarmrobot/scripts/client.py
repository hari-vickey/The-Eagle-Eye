#!/usr/bin/env python3
"""
Flipkart - Grid 3.0 - Robotics Competition
ROS Node - client.py (yet to be completed)
This node will do the following :
    1. Read the samplesheet.xlsx
    2. Send Goal to the Server using ROS Action
"""
# Importing Required Modules
import os
import math
import rospy
import rospkg
import actionlib
import threading
import pandas as pd
from helper import function
from swarmrobot.msg import msgBot2Action, msgBot2Goal, msgBot2Result
from swarmrobot.msg import msgBot4Action, msgBot4Goal, msgBot4Result

# Class Client
class Client():

    """
    This class has all the required functions to complete the task as
    mentioned in the doc string of this file
    """

    # Constructor
    # Initializing the variables of this class
    def __init__(self):

        #Initialize SimpleActionClientTurtle
        self._ac2 = actionlib.ActionClient('/action_bot2', msgBot2Action)
        self._ac4 = actionlib.ActionClient('/action_bot4', msgBot4Action)

        # Dictionary to Store all the goal handels
        self.goal_no_2, self.goal_no_4 = 0, 0
        self._goal_handles_2, self._goal_handles_4 = {}, {}

        # Wait for Bots's Action Server
        self._ac2.wait_for_server()
        self._ac4.wait_for_server()
        print("Action Server Up")

        print("waiting for Aruco Markers Detection")
        # rospy.sleep(3)
        self.location = function.read_location()
        print(self.location)
        self.read_sheet()
        self.algorithm()

    # Function to read Excel Sheet
    def read_sheet(self):
        """
        This Function will read the excel sheet and sort 
        induct stations
        """
        rp = rospkg.RosPack()
        pkg_path = rp.get_path('swarmrobot')
        sheet = "{}/sheet/Sample_Data.xlsx".format(pkg_path)
        df = pd.read_excel(sheet, index_col=None, na_values=['NA'], usecols = "A:C")
        self.df1 = df[df['Induct Station']==1]
        self.df2 = df[df['Induct Station']==2]

    # Function On_Transition_2
    def on_transition_2(self, goal_handle):
        """
        This function will be called when there is a change of state in the 
        Action Client State Machine
        """
        # from on_goal() to on_transition(). goal_handle generated by send_goal() is used here.
        result = msgBot2Result()
        ind = 0
        for i in self._goal_handles_2:
            if self._goal_handles_2[i] == goal_handle:
                ind = i + 1
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " + str(ind))

        # Comm State - Monitors the State Machine of the Client 
        # which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Wating for Result
        # Comm State = 7 -> Done

        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(ind) + ": Goal just went active.")

        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(ind) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())
            result = goal_handle.get_result()
            rospy.loginfo(result.flag)
            if result.flag == True:
                rospy.loginfo("Goal successfully completed. " + \
                 + "Client Goal Handle #: " + str(ind))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " + str(ind))

    # Function Send Goal for Bot2
    def send_goal_2(self, *args):
        """
        This function is used to send Goals to Action Server
        """
        # Create a Goal Message object
        goal = msgBot2Goal()
        goal.induct_station = args[0]
        goal.induct_x = args[1]
        goal.induct_y = args[2]
        goal.goal_x = args[3]
        goal.goal_y = args[4]
        rospy.loginfo("Goal Sent")
        print("Induct Station - " + str(args[0]))
        print("Goal Point - " + "(" + str(args[3]) +", " + str(args[4]) + ")")
        # self.on_transition - It is a function pointer to a function,
        # which will be called when there is a change of state in the 
        # Action Client State Machine
        goal_handle = self._ac2.send_goal(goal, self.on_transition_2, None)

        return goal_handle

    # Function On_Transition_4
    def on_transition_4(self, goal_handle):
        """
        This function will be called when there is a change of state in the 
        Action Client State Machine
        """
        # from on_goal() to on_transition(). goal_handle generated by send_goal() is used here.
        result = msgBot4Result()
        ind = 0
        for i in self._goal_handles_4:
            if self._goal_handles_4[i] == goal_handle:
                ind = i + 1
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " + str(ind))

        # Comm State - Monitors the State Machine of the Client 
        # which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Wating for Result
        # Comm State = 7 -> Done

        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(ind) + ": Goal just went active.")

        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(ind) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())
            result = goal_handle.get_result()
            rospy.loginfo(result.flag)
            if result.flag == True:
                rospy.loginfo("Goal successfully completed. " + \
                 + "Client Goal Handle #: " + str(ind))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " + str(ind))

    # Function Send Goal for Bot4
    def send_goal_4(self, *args):
        """
        This function is used to send Goals to Action Server
        """
        # Create a Goal Message object
        goal = msgBot4Goal()
        goal.induct_station = args[0]
        goal.induct_x = args[1]
        goal.induct_y = args[2]
        goal.goal_x = args[3]
        goal.goal_y = args[4]
        rospy.loginfo("Goal Sent")
        print("Induct Station - " + str(args[0]))
        print("Goal Point - " + "(" + str(args[3]) +", " + str(args[4]) + ")")
        # self.on_transition - It is a function pointer to a function,
        # which will be called when there is a change of state in the 
        # Action Client State Machine
        goal_handle = self._ac4.send_goal(goal, self.on_transition_4, None)

        return goal_handle

    # Function Algorithm
    def algorithm(self):
        """
        This function is responsible to complete the entire task.
        It is also combined with multiple control statements to
        get optimal results
        """
        ###############################
        #                             #
        ##                           ##
        ###                         ###
        # Lot of Work need to be done #
        ###                         ###
        ##                           ##
        #                             #
        ###############################
        for i in range(0, 15):
            ind_stn = int(self.df1.iloc[i][1])
            city = self.df1.iloc[i][2]
            print(ind_stn, city)
            start = (self.location[ind_stn][0], self.location[ind_stn][1])
            goal = self.closest_point(self.location[city], start)
            print(start, goal)
            self._goal_handles_2[self.goal_no_2] = self.send_goal_2(ind_stn, 
                                                     start[0], start[1], 
                                                     goal[0], goal[1])
            self.goal_no_2 += 1

        for i in range(0, 15):
            ind_stn = int(self.df2.iloc[i][1])
            city = self.df2.iloc[i][2]
            print(ind_stn, city)
            start = (self.location[ind_stn][0], self.location[ind_stn][1])
            goal = self.closest_point(self.location[city], start)
            print(start, goal)
            self._goal_handles_4[self.goal_no_4] = self.send_goal_4(ind_stn, 
                                                     start[0], start[1], 
                                                     goal[0], goal[1])
            self.goal_no_4 += 1


    # Function to identify the closest point
    def closest_point(self, ls, pos):
        """
        This Function will choose the closest point of the destination
        from the current position of the bot.
        """
        x, y = pos
        d = list(map(lambda t: math.sqrt(pow(t[0]-x,2)+pow(t[1]-y,2)),ls))
        min_res = min(d)
        i = d.index(min_res)

        return ls[i]

    # Function to validate point
    def validate_point(self, coord, points):
        """
        This function will validate the point with obstacles of
        its presence and returns the result as 1 or 0
        """
        try:
            points.index(coord)
            flag = 0
        except ValueError:
            flag = 1

        return flag

    # Destructor of the Class
    def __del__(self):
        rospy.loginfo('\033[94m' + "Shutting Down" + '\033[0m')

# Main Function
def main():
    """
    This is the start of execution of this node
    """
    # Initializing the Node
    rospy.init_node('node_client', anonymous=True)

    # Creating Object for the Class Client
    cli = Client()
    try:
        # Spinning the Main Function
        rospy.spin()

    except KeyboardInterrupt:
        rospy.loginfo("Shutting down")

        # Deleting the Created Object if Interrupted
        del cli

        # Destroying all the cv2 Windows Created
        cv2.destroyAllWindows()

if __name__ == '__main__':
    main()